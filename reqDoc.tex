\documentclass[a4paper,11pt,notitlepage]{article}
\usepackage{xspace}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{paralist}
\usepackage{hanging}
\usepackage{enumerate}
\usepackage{color}
\usepackage{ulem}
\usepackage{hyperref}

\def\TSL{Train Scripting Language\xspace}
\def\CS{Control Progam\xspace}
\def\LC{Local Copy of Train State\xspace}
\def\TN{Track Node\xspace}

\title{{\bf Software Project Requirements Specification} \\ for \\ {\bf Train Scripting Python Library}}
\author{Prepared by Alex Wipf, Sebastian Imlay, Max Aussendorf, Paul Sheraton}
\parskip 7.2pt

\begin{document}
\maketitle
\pagebreak
\tableofcontents
%\addtocounter{page}{-1}

\newpage
\section{Introduction}
\subsection{Vision Statement}
For Dr. Martin Osborne, who has requested a language and framework for controlling model trains.  The \TSL is a library that extends the functionality of model train operations to the script writer.  Unlike other libraries for controlling external hardware, the \TSL provides \verb=when <expr> do <statements>= and \verb=wait until <expr>= features to allow for event driven statement blocks.  Our product provides a library implementing low level functionality for manipulating trains as well as higher level functions to allow for a more user friendly scripting experience.
\subsection{Purpose}
Creation of a Python library to communicate with the control software for the model train in CF408. This library will allow users to create scripts which can control the trains without human interaction.
\subsection{Background}
The current setup in the train lab provides for basic controls of the trains and track, but all under the manual control of throttles, or throttle-like interfaces. The AdaRail program allows users to guarantee all actions will be safe, but again only using throttles. The aim of this project is to break free of this limitation, and allow a user to write programs to control the trains entirely.
\subsection{Product Perspective}
We would like to create a scripting language that anybody can use to program higher level functions on the railroad. The scripting language itself would be the building blocks that can be used to build a multitude of scripts ranging from things like scheduling the trains to visit certain locations, to making it so that the trains slow down in certain sections.
\subsection{Document Definitions}
\paragraph{\TSL} This refers to the Python with our library added on.
\paragraph{\CS} This refers to the AdaRail program which works between the virtual throttles (such as our Scripting Language) and the track itself. This is the program our library will directly communicate with.
\paragraph{\LC} Our library shall have a thread which listens to all messages, and update a local copy of the train states. For accessor functions, this local copy can be the one read.
\paragraph{\TN} The track can be thought of as a complex graph of sensors and switches. We refer to either as \TN{}s.
\subsection{References}

\newpage
\subsection{Scope}
For this project, we provide the library and framework for the \TSL. These features include the underlying functionality needed for initialization, observation and manipulation objects on the track.  This includes throwing and closing of switches, variation of a track and train state.  More higher level functions include a modified Dijkstra's algorithm for determining a path between two locations.  Further expansion of this project would allow for a web interface and possibly a grammar addition to the Python Language for \verb=when <expr> do <statements>= and \verb=wait until <expr>= style syntax.

\subsection{Risk Assessment}
We have aimed to marginalize risks as much as we can in specification. We have required nothing which cannot be implemented in a Python Library.

\newpage
\section{General Description}
\subsection{User Characteristics}
Users of this library will be programmers, and will be interested in the model trains. Since this is built on top of Python, anyone using it should be expected to know a bit of python before they start using our library. While the learning curve may be steeper than that of a manual throttle, this library will be much more powerful. We have specified objects and functionality in such a way that it should be intuative to manipulate the train system.
\subsection{Library Features}
Upon inclusion of the library, a user will be able to either start the \CS, or receive from it information about the current state of the train system. An XML document with the physical topology will have to be read in. The user will be able to call library functions, declare objects, and call methods on those objects. All of these features will be to allow the user to poll and manipulate the train system.

\newpage
\section{Specific Requirements}
\subsection{Back End}
The initialization functions shall start several background threads. A great deal of things will have to happen behind the scenes to the user.
\paragraph{\LC} A thread will have to watch all traffic on the network and update the \LC as changes are made. To support user level multithreading, as well as the internal multithreading, this data and all accessor/modifiers of it must incorporate mutual exclusion.
\paragraph{Observer} For our event driven functionality, there will have to be a thread whose job it is to monitor changes to the \LC and run even driven functions as needed.
\subsection{Global Variables}
\paragraph{track} The track must be a global variable. All the trains in this script shall share the track. The decription of the object is later in this section.
\subsection{Constant Enums and Flags}
\paragraph{direction} A direction type is necessary so that users can assign trains directions to constant values. This enum shall contain:
\begin{itemize}
\item forward
\item backward
\end{itemize}
\paragraph{trainState} A trainState type is necessary so that users can ask trains their state. This enum shall contain:
\begin{itemize}
\item moving
\item stopped
\item waiting
\item error
\end{itemize}
\paragraph{switchState} A switchState type is necessary so that users can assign switches constant values. This enum shall contain:
\begin{itemize}
\item closed
\item thrown
\item moving
\end{itemize}
\paragraph{pathFlags} Flags to the path creating functions are necessary so that users can choose what to allow and prioritize. These flags contain:
\begin{itemize}
\item prioritize : distance or speed
\item doubleBacks : allow or disallow
\item[default:] prioritize=distance, doubleBacks=disallow
\end{itemize}
When referring to allowing doubleBacks or not, it is meant for paths where the actual shortest path may require stopping and reversing down a different branch of a switch. The user may find this undesirable.
\subsection{Classes in Library}
All of these objects will exist in the \LC. Their accessors will access the \LC for all information, and the setters will send messages to the \CS. This data must be in one central location so the background threads can watch and set it. \\ \\
All classes should have a string representation for output (debugging, etc).\\
This can be achieved in python with a \verb!__repr__! function in each class. To use it, call \verb!str(object)! for the object to display.
\begin{verbatim}
class Foo:
    def __repr__(self):
        return 'This is what I look like'
\end{verbatim}

\subsubsection{Train}
The train object shall be constructable by users.
\paragraph{Data}
The train object shall be either constructed by the user manually and sent to the \CS, or it shall be constructed by the getTrains function from its data received from the \CS.
\begin{itemize}
\item A unique identifier, which shall be the same ID as is used in the \CS.
\item The location of the train, given in an array of sensors. All the sensors underneath the train, plus those immediately in front of and behind the train shall be included in this array. Important: Direction is dependant in the order of this list. This list shall be in front to back order for the physical train.
\item A power level for the current speed the train is moving
\item trainState
\item The direction the train is moving
\item Whether or not the lights are on
\item Whether or not the bell is on
\item The length of the train
\end{itemize}
\paragraph{Functions}
The train object shall be accessible by the following functions.
\subparagraph{train(integer id, int length, location loc)} Constructor. 
\begin{description}
\item[\hspace{1cm}Pre:] The train object does not exist. 
\item[\hspace{1cm}Post:] The train object exists, and it is either ``set'' or ``stolen'' through the \CS. The \CS will know where it is located based on the input, and the physical train is expected to be halted at initialization. If the ID is invalid for the \CS, an exception shall be sent back.
\item[\hspace{1cm}Example:]
\begin{verbatim}

	myLoc = location( [ s1, s2, s3, s4 ] )
    myTrain = train(1204, 43, myLoc)
\end{verbatim}
\end{description}

\subparagraph{getTrains} Alternative multi-constructor. 
\subparagraph{getID}
\begin{description}
\item[\hspace{1cm}Pre:] The train objects do not exist. 
\item[\hspace{1cm}Post:] Train objects are created from the data received from the \CS by making a request for said data. An exception is raised if the \CS is not running. A list of all the train objects is returned.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    trains = getTrains()     #trains is a list
\end{verbatim}
\end{description}

\begin{description}
\item[\hspace{1cm}Pre:] The train object must exist. 
\item[\hspace{1cm}Post:] Returns the unique identifier of the train. (\CS id)
\item[\hspace{1cm}Example:]
\begin{verbatim}

    myID = train1.getID()
\end{verbatim}
\end{description}

\subparagraph{getLocation} 
\begin{description}
\item[\hspace{1cm}Pre:] The train object must exist. 
\item[\hspace{1cm}Post:] Returns the array of sensors the train is occupying.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    myLoc = train1.getLocation()
\end{verbatim}
\end{description}


\subparagraph{occupies(location l)} 
\begin{description}
\item[\hspace{1cm}Pre:] The train object must exist. 
\item[\hspace{1cm}Post:] Returns true or false if any part of the train's location intersects with location l.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    if train1.occupies(loc):
        print "occupying loc"
\end{verbatim}
\end{description}

\subparagraph{getPower} 
\begin{description}
\item[\hspace{1cm}Pre:] The train object must exist. 
\item[\hspace{1cm}Post:] Returns the current power level of the train.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    myPower = train1.getPower()
\end{verbatim}
\end{description}


\subparagraph{setPower(integer p)} 
\begin{description}
\item[\hspace{1cm}Pre:] The train object must exist.
\item[\hspace{1cm}Post:] A message is sent to the \CS setting the current power level of the train to that which was given.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    train1.setPower(100)
\end{verbatim}
\end{description}

\subparagraph{getDirection} 
\begin{description}
\item[\hspace{1cm}Pre:] The train object must exist. 
\item[\hspace{1cm}Post:] Returns the current direction of the train (see 'direction' enum).
\item[\hspace{1cm}Example:]
\begin{verbatim}

	myDir = train1.getDirection()    
\end{verbatim}
\end{description}

\subparagraph{setDirection(direction d)} 
\begin{description}
\item[\hspace{1cm}Pre:] The train object must exist. 
\item[\hspace{1cm}Post:] A message is sent to the \CS setting the current direction of the train to that which was given (see 'direction' enum).
\item[\hspace{1cm}Example:]
\begin{verbatim}

	train1.setDirection(direction.forward)
\end{verbatim}
\end{description}

\subparagraph{getLights}
\begin{description}
\item[\hspace{1cm}Pre:] The train object must exist. 
\item[\hspace{1cm}Post:] Returns whether or not the lights are on.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    if train1.getLights():
        print "lights are on"
\end{verbatim}
\end{description}

\subparagraph{setLights(boolean l)} 
\begin{description}
\item[\hspace{1cm}Pre:] The train object must exist.
\item[\hspace{1cm}Post:] A message is sent to the \CS setting the current state of the lights to on or off based on input.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    train1.setLights(true)
\end{verbatim}
\end{description}

\subparagraph{getBell} 
\begin{description}
\item[\hspace{1cm}Pre:] The train object must exist. 
\item[\hspace{1cm}Post:] Returns whether or not the bell is on.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    if train1.getBell():
        print "bell is on"
\end{verbatim}
\end{description}

\subparagraph{setBell(boolean l)} 
\begin{description}
\item[\hspace{1cm}Pre:] The train object must exist. 
\item[\hspace{1cm}Post:] A message is sent to the \CS setting the current state of the bell to on or off based on input.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    train1.setBell(true)
\end{verbatim}
\end{description}

\subparagraph{soundHorn} 
\begin{description}
\item[\hspace{1cm}Pre:] The train object must exist. 
\item[\hspace{1cm}Post:] A message is sent to the \CS that the train should sound its horn. The horn is a pulse, so there is no getter for this. (It has no state).
\item[\hspace{1cm}Example:]
\begin{verbatim}

    train1.soundHorn()
\end{verbatim}
\end{description}

\subparagraph{mute} 
\begin{description}
\item[\hspace{1cm}Pre:] The train object must exist. 
\item[\hspace{1cm}Post:] A message is sent to the \CS that the train should mute its sound.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    train1.mute()
\end{verbatim}
\end{description}

\subparagraph{unmute} 
\begin{description}
\item[\hspace{1cm}Pre:] The train object must exist. 
\item[\hspace{1cm}Post:] A message is sent to the \CS that the train should unmute its sound.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    train1.unmute()
\end{verbatim}
\end{description}

\subparagraph{getSwitchInFront} 
\begin{description}
\item[\hspace{1cm}Pre:] The train object must exist. 
\item[\hspace{1cm}Post:] Returns a reference to the switch which is closest to the train in front of it. The front is determined by direction of movement, not the engine of the train.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    nextSwitch = train1.getSwitchInFront()
\end{verbatim}
\end{description}

\subparagraph{getHeadSensor} 
\begin{description}
\item[\hspace{1cm}Pre:] The train object must exist. 
\item[\hspace{1cm}Post:] Returns a reference to the sensor in the front of this train's location. The front is determined by direction of movement, not the engine of the train.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    mySensor = train1.getHeadSensor()
\end{verbatim}
\end{description}

\subparagraph{stop} 
\begin{description}
\item[\hspace{1cm}Pre:] The train object must exist. 
\item[\hspace{1cm}Post:] A message is sent to the \CS that the train should stop immediately.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    train1.stop()
\end{verbatim}
\end{description}

\subparagraph{getState} 
\begin{description}
\item[\hspace{1cm}Pre:] The train object must exist. 
\item[\hspace{1cm}Post:] A trainState is returned for which state the train is in (see 'trainState' enum).
\item[\hspace{1cm}Example:]
\begin{verbatim}

    myState = train1.getState()
\end{verbatim}
\end{description}

\subparagraph{follow(int power, Path p)} 
\begin{description}
\item[\hspace{1cm}Pre:] Train and path objects must exist. The start of the path must be the same section as the front of the train occupies. 
\item[\hspace{1cm}Post:] Train will follow the path. This is a blocking operation. An exception is raised if the train is put into a blocking state.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    myPath = path( [ sensor1, sensor2, sensor3, sensor4 ] )
    train1.follow(50, myPath)
\end{verbatim}
\end{description}

\subsubsection{Track}
The track object shall be either constructed by reading the XML file and sent to the \CS, or it shall be constructed by the getTrackState function from its data received from the \CS.
Note: This is a global object of which only one may exist. The global variable `track' is reserved for this.
\paragraph{Data}
The train object shall contain the following data. It is a graph-like abstraction of the topology.
\begin{itemize}
\item An aggregate of all sensors and switches.
\end{itemize}
\paragraph{Functions}
The track object shall be accessible by the following functions.

\subparagraph{readXML(XMLDoc topology)}
\begin{description}
\item[\hspace{1cm}Pre:] The track object must not exist.
\item[\hspace{1cm}Post:] Track object is created from the XML file's topology. This constructs the global object of the track. A maximum of one track object shall exist; exception shall be raised if the global track already exists, or if the document is non-conforment to the XML standards defined.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    readXML (layout.xml)  #creates a global 'track' object
\end{verbatim}
\end{description}

\subparagraph{acquireTrackState} Alternative constructor.
\begin{description}
\item[\hspace{1cm}Pre:] The track object must not exist. \CS must be running.
\item[\hspace{1cm}Post:] Track object is created from the data received from the \CS by making a request for said data. An exception is raised if the \CS is not running.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    if isControlProgRunning():
        acquireTrackState()
\end{verbatim}
\end{description}

\subparagraph{getSensor(integer ID)}
\begin{description}
\item[\hspace{1cm}Pre:] The track object must exist.
\item[\hspace{1cm}Post:] Returns a reference to the sensor with the given ID. An exception is raised if it does not exist.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    mySensor = getSensor (47)
\end{verbatim}
\end{description}

\subparagraph{getSwitch(integer ID)}
\begin{description}
\item[\hspace{1cm}Pre:] The track object must exist.
\item[\hspace{1cm}Post:] Returns a reference to the switch with the given ID. An exception is raised if it does not exist.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    mySwitch = getSwitch (7)
\end{verbatim}
\end{description}


\subsubsection{Sensor}
The sensor objects are created upon the construction of a track. They are not constructable by a user. Sensors represent a \TN in the track graph.
\paragraph{Data}
\begin{itemize}
\item A unique identifier, which shall be the same ID from the XML file.
\item A reference to the next adjacent \TN.
\item The distance to the next adjacent \TN.
\item A reference to the previous adjacent \TN.
\item The distance to the previous adjacent \TN.
\end{itemize}
\paragraph{Functions}
The sensor object shall be accessible by the following functions.

\subparagraph{getID}
\begin{description}
\item[\hspace{1cm}Pre:] The sensor object must exist.
\item[\hspace{1cm}Post:] Returns the unique identifier of the sensor.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    mySensor = getSensor (7)
    mySensorID = mySensor.getID()    # returns 7
\end{verbatim}
\end{description}

\subparagraph{getNext}
\begin{description}
\item[\hspace{1cm}Pre:] The sensor object must exist.
\item[\hspace{1cm}Post:] Returns next \TN.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    mySensor = getSensor (7)
    nextDistance = mySensor.getDistanceNext()
\end{verbatim}
\end{description}

\subparagraph{getPrev}
\begin{description}
\item[\hspace{1cm}Pre:] The sensor object must exist.
\item[\hspace{1cm}Post:] Returns previous \TN.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    mySensor = getSensor (7)
    prevDistance = mySensor.getDistancePrev()
\end{verbatim}
\end{description}


\subsubsection{Switch}
The switch objects are created upon the construction of a track. They are not constructable by a user. Switches represent a \TN in the track graph.
\paragraph{Data}
\begin{itemize}
\item A unique identifier, which shall be the same ID from the XML file.
\item The current state of the switch, either thrown or closed.
\item A reference to the adjacent \TN.
\item The distance to the adjacent \TN.
\item A reference to the adjacent \TN when the switch is thrown.
\item The distance to the \TN when the switch is thrown.
\item A reference to the adjacent \TN when the switch is closed.
\item The distance to the \TN when the switch is closed.
\item The requested power level. (Actual power may be less; it depends on the power limit of section the train is on)
\end{itemize}
\paragraph{Functions}
The switch object shall be accessible by the following functions.

\subparagraph{getID}
\begin{description}
\item[\hspace{1cm}Pre:] The switch object must exist.
\item[\hspace{1cm}Post:] Returns the unique identifier of the switch.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    mySwitch = getSwitch (3)
    mySwitchID = mySwitch.getID()    # returns 3
\end{verbatim}
\end{description}

\subparagraph{getState}
\begin{description}
\item[\hspace{1cm}Pre:] The switch object must exist.
\item[\hspace{1cm}Post:] Returns the current state (Closed or Thrown) of the switch. (see 'switchstate' enum)
\item[\hspace{1cm}Example:]
\begin{verbatim}

    mySwitch = getSwitch (3)
    state = mySwitch.getState()
\end{verbatim}
\end{description}

\subparagraph{getClosed}
\begin{description}
\item[\hspace{1cm}Pre:] The switch object must exist.
\item[\hspace{1cm}Post:] Returns the \TN along the closed path of the switch.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    mySwitch = getSwitch (3)
    theClosedNode = mySwitch.getClosedNode()
\end{verbatim}
\end{description}

\subparagraph{getThrown}
\begin{description}
\item[\hspace{1cm}Pre:] The switch object must exist.
\item[\hspace{1cm}Post:] Returns the \TN along the open path of the switch.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    mySwitch = getSwitch (3)
    theClosedNode = mySwitch.getOpenNode()
\end{verbatim}
\end{description}

\subparagraph{getNarrow}
\begin{description}
\item[\hspace{1cm}Pre:] The switch object must exist.
\item[\hspace{1cm}Post:] Returns the \TN along the narrow (opposite the closed/open side) path of the switch.
\item[\hspace{1cm}Example:]
\begin{verbatim}

    mySwitch = getSwitch (3)
    theClosedNode = mySwitch.getNarrowNode()
\end{verbatim}
\end{description}

\subparagraph{Throw}
\begin{description}
\item[\hspace{1cm}Pre:] The switch must exist.
\item[\hspace{1cm}Post:] A message is sent to the \CS setting the current state of the switch to Thrown. Exception will be raised if the \CS prevents the operation (possibly due to ownership of section).
\item[\hspace{1cm}Example:]
\begin{verbatim}

    mySwitch = getSwitch (3)
    mySwitch.Throw()
\end{verbatim}
\end{description}

\subparagraph{Close}
\begin{description}
\item[\hspace{1cm}Pre:] The switch must exist.
\item[\hspace{1cm}Post:] A message is sent to the \CS setting the current state of the switch to Closed. Exception will be raised if the \CS prevents the operation (possibly due to ownership of section).
\item[\hspace{1cm}Example:]
\begin{verbatim}

    mySwitch = getSwitch (3)
    mySwitch.Close()
\end{verbatim}
\end{description}


\subsubsection{Location}
A location is a user defined aggregate of contiguous sensors.
\paragraph{Data}
\begin{itemize}
\item An array of sensors.
\end{itemize}
\paragraph{Functions}
The location object shall be accessible by the following functions.

\subparagraph{location(list sensors)} Constructor. 
\begin{description}
\item[\hspace{1cm}Pre:] The location object does not exist.
\item[\hspace{1cm}Post:] The location object is created as the space between the provided sensors. An exception is raised if they are not adjacent.
\item[\hspace{1cm}Example:]
\begin{verbatim}
    myLocation = location(mySensors)    #List of sensor objects
\end{verbatim}
\end{description}

\subparagraph{getLength} 
\begin{description}
\item[\hspace{1cm}Pre:] The location must exist.
\item[\hspace{1cm}Post:] Returns the length of the location.
\item[\hspace{1cm}Example:]
\begin{verbatim}
    length = myLocation.getLength()
\end{verbatim}
\end{description}

\subparagraph{getOccupant}
\begin{description}
\item[\hspace{1cm}Pre:] The location must exist. 
\item[\hspace{1cm}Post:] Returns a list of references to the trains who occupy any part of this location. Returns null if the entire location is unoccupied.
\item[\hspace{1cm}Example:]
\begin{verbatim}
    myOccupant = myLocation.getOccupant()
\end{verbatim}
\end{description}

\subparagraph{getSwitches}
\begin{description}
\item[\hspace{1cm}Pre:] The location must exist.
\item[\hspace{1cm}Post:] Returns the list of switches in this location.
\item[\hspace{1cm}Example:]
\begin{verbatim}
    mySwitches = myLocation.getSwitches()   
\end{verbatim}
\end{description}

\subparagraph{getSections}
\begin{description}
\item[\hspace{1cm}Pre:] The location must exist. 
\item[\hspace{1cm}Post:] Returns the list of sections in this location.
\item[\hspace{1cm}Example:]
\begin{verbatim}
    mySections = myLocation.getSections()   
\end{verbatim}
\end{description}

\subsubsection{Section}
Sections are subsets of locations. They must be a pair of adjacent sensors. All of the methods of locations are valid on sections, as well as a few others.
\paragraph{Data}
\begin{itemize}
\item Pair of sensors.
\end{itemize}
\paragraph{Functions}
The section object shall be accessible by the following functions.
\subparagraph{section(sensor a, b)} Constructor.
\begin{description}
\item[\hspace{1cm}Pre:] The section does not exist. 
\item[\hspace{1cm}Post:] A section object is created as the space between the pair of sensor ends. An exception is raised if they are not adjacent.
\item[\hspace{1cm}Example:]
\begin{verbatim}
    mySection = getSection(sensor1,sensor2)
\end{verbatim}
\end{description}

\subparagraph{prepare}
\begin{description}
\item[\hspace{1cm}Pre:] The section must exist.
\item[\hspace{1cm}Post:] Any switches within this section are thrown or closed such that a train may travel between the section's pair of sensors. An exception is raised if \CS prevents the operation.
\item[\hspace{1cm}Example:]
\begin{verbatim}
    mySection.prepare()
\end{verbatim}
\end{description}

\subparagraph{isPrepared}
\begin{description}
\item[\hspace{1cm}Pre:] The section must exist.
\item[\hspace{1cm}Post:] Returns true or false if a the switches within this section are situated to allow travel from this section's pair of sensors.
\item[\hspace{1cm}Example:]
\begin{verbatim}
    status = mySection.isPrepared()
\end{verbatim}
\end{description}

\subparagraph{getLength}
\begin{description}
\item[\hspace{1cm}Pre:] The section must exist. 
\item[\hspace{1cm}Post:] Returns the length of the section.
\item[\hspace{1cm}Example:]
\begin{verbatim}
    myLength = mySection.getLength()
\end{verbatim}
\end{description}

\subparagraph{getOccupant}\begin{description}
\item[\hspace{1cm}Pre:] The section must exist.
\item[\hspace{1cm}Post:] Returns a reference to the train who occupies this section. Returns null if the section is unoccupied.
\item[\hspace{1cm}Example:]
\begin{verbatim}
    occupant = mySection.getOccupant()
\end{verbatim}
\end{description}

\subparagraph{getSwitches}\begin{description}
\item[\hspace{1cm}Pre:] The section must exist.
\item[\hspace{1cm}Post:] Returns the list of switches in this section.
\item[\hspace{1cm}Example:]
\begin{verbatim}
    switches = mySection.getSwitches()
\end{verbatim}
\end{description}

\subparagraph{getSpeedLimit}
\begin{description}
\item[\hspace{1cm}Pre:] The section must exist.
\item[\hspace{1cm}Post:] Returns the speed of this section.
\item[\hspace{1cm}Example:]
\begin{verbatim}
    speedLimit = mySection.getSpeedLimit()
\end{verbatim}
\end{description}


\subsubsection{Path}
A path is a user defined aggregate of contiguous sensors. Although it has the same data as a location, it has different real-world meaning, and its functions are different.
\paragraph{Data}
\begin{itemize}
\item An array of sensors.
\end{itemize}
\paragraph{Functions}
The path object shall be accessible by the following functions.
\subparagraph{path(list sensors)} Constructor. Pre: The path object does not exist. Post: The path object is created as the list of provided sensors.
\subparagraph{getLength} Pre: The path must exist. Post: Returns the length of the path.
\subparagraph{getSwitches} Pre: The path must exist.  Post: Returns the list of switches along the path.
\subparagraph{getSections} Pre: The path must exist.  Post: Returns the list of sections along the path.


\subsection{Functions in Library}
These functions are not called on objects, but are first class functions of the library itself.

\subsubsection{Initialization}
Users will need to be able to initialize the \CS, or get data from it if it is running. To make a decision about this, they will need to be able to tell if it is running already.
\paragraph{isControlProgRunning()} Pre: None. Post: Returns true if the \CS is already running.
\paragraph{initControlProg()} Pre: \CS can not be running. Post: \CS will be running and get the trains after this. %and will be given the inital state of the \emph{stopped} trains.
\paragraph{Alternative to initialization} getTrainState and getTrackState (see Train and Track classes) can be called if the \CS is already running to initialize the \LC.
\subsubsection{More Functions}
These are the remaining standard functions in the library.
\paragraph{stopTrains(list trains)}
\begin{description}
\item[\hspace{1cm}Pre:] None.
\item[\hspace{1cm}Post:] Stops all trains specified immediately. If list is empty, then all trains in the system are stopped immediately.
\end{description}

\paragraph{getDistance(node n1, node n2, [flags])}
\begin{description}
\item[\hspace{1cm}Pre:] Both nodes must exist.
\item[\hspace{1cm}Post:] Returns the distance along the track between the nodes.
\item[\hspace{1cm}Flags:]
\begin{description}
\item{DISTANCE}
\end{description}
\item[\hspace{1cm}Example:]
\begin{verbatim}

    
\end{verbatim}
\end{description}


\subsubsection{waitUntil(function cond)} Pre: None. Post: Control is blocked until function cond returns true. Polling time shall be no more frequent than 0.1 seconds.

\subsection{Event Driven Functions}
Event driven functions are encapsulated by a trainEvent class. For management of event driven functions, there shall be an observer thread. The user may create trainEvent objects which may be manually entered into the observer, and can be automatically or manually removed from it. Creation shall require use of higher order functions.
\subsubsection{trainEvent Class}
\paragraph{Data}
\begin{itemize}
\item A function ``condition" which must return a boolean
\item A function ``event" which must have no return
\item Count for automatic removal ($0 =$ infinite)
\end{itemize}
\paragraph{Functions}
The following functions allow manual control of a train event's existence in the observer.
\subparagraph{trainEvent(func cond, func event, int count)} Constructor. Pre: The trainEvent does not exist. Post: The trainEvent exists.
\subparagraph{register} Pre: The trainEvent must exist. Post: The trainEvent will be registered in the observer. No op if it already existed in it.
\subparagraph{unregister} Pre: The trainEvent must exist. Post: The trainEvent will be removed from the observer. No op if it was not registered in it.
\paragraph{Description}
The observer will watch the \LC, and when any of its registered trainEvents' condition functions return true, it will spawn a new thread to execute their event function. This is required to be run in a new thread so as not to block other events from occuring. No event's execute function shall be running more than once at a time. If the count was set by the user to zero, it shall never be automatically removed. If the count was set to a positive integer, the event shall decriment its count every time its event occurs. When it reaches zero, it is automatically unregistered. The observer shall check these no more frequently than 0.1 seconds.
These functions are non-blocking and shall return immediately.

\subsection{High Level Functions}
These functions are more ambitious, and should only be attempted after all the previously defined functions have been defined.
\paragraph{train.getVelocity} Pre: Train object must exist. Post: Returns velocity in m/s or cm/s. Will have to do so using knowledge of the track length and time between sensors firing.
\paragraph{train.goTo(section destination)} Pre: Train object must exist. Post: Train shall take the shortest path which is unblocked to the specified section, where it shall stop. This function blocks control until it has reached this destination. This will require a dynamic algorithm which can take into account which sections are blocked and other moving trains.
\paragraph{train.followPath(list nodes)} Pre: Train and nodes must exist. Post: Train takes the shortest path from each node to the next until the final node, when it stops. This can be thought of as a repeated calling of the goTo function. This function blocks control until it has reached the final destination.
\paragraph{getPath(s1, s2)} Pre: The track must exist.  Post: Returns the shortest logal distance from s1 to s2 with no double back (possibly reverse).

\newpage
\section{External Interface Requirements}
    In this section, we go over the general interface requirements for the train scripting language.
\subsection{Control Program}
    There shall be one or more threads which intaract between the control session and the current train script instance.
\subsection{Train Topology}
    XML Document.

\newpage
\section{Additions to Current Software}
    In this section, we go over what additions needed to be added to the current architecture.
\subsection{Design Constraints}
\subsection{Control Program}
    A messaging protocol between ``virtual'' remotes the control program shall be added.  This protocol is mainly for initializing the train and knowing if the loco buffer server is running. The getTrainState and getTrackState functions will need a new message to ask the \CS for data, and a new one to receieve said data.
    \\Some methodology for exceptions must be added to \CS as well. This should be used sparingly, as we do not want to add very many new functions to the \CS. One example where it is necessary is the train constructor. If the train cannot be get/set, an error message should be sent back.
\subsection{XML Specification}
    The list of additions to the XML specification is:
\begin{enumerate}
    \item Length between each sensor on the track.
    \item Speedlimits on a given section.
\end{enumerate}

\newpage
\section{Non-Functional Requirements}
\subsection{Performance Requirements}

\subsection{Security Requirements}

\subsection{Safety Requirements}
The \TSL may interface only with the \CS. It may not talk directly to the Loco Buffer Server, as this would be a high risk environment for scripting. A bug in a script may frequently cause collisions or derailments, so we are disallowing this case entirely.

\newpage
\section{Additional Functionality For Future Releases}
Future releases may include these features or others, so design must be portable and accessable enough to allow for that.
\subsection{Front End}
The \TSL we have specified is powerful, but some features such as those using higher order functions will lack clarity and intuitivity. A front end may come in any of the following flavors, or a combination of them.
\begin{enumerate}
    \item Graphical User Interface. A GUI could be added on top which may have a visual representation of the entire track system, displaying data from \LC in real time. It should have an ability to load scripts or an interactive scripting interface.
    \item Scripting Wrapper. As mentioned earlier, some aspects of this library will be less than ideal syntactically. This wrapper could translate higher level human language into something the \TSL can understand.
\end{enumerate}
\subsection{Speed Limits}
Speed limits for each section could be added to the XML Documents, and the \TSL could enforce them automatically. This is a feature that would have to be specified in detail when implemented. Likely, the user could toggle enforcement on and off, and when actived it would send messages to the \CS slowing trains down if they enter a section which has a speed limit lower than the desired speed of the train. This would also require an extra field in the train class to keep track of the desired power level verus the actual power level.

\newpage
\section{Sample Scripts}
In this section we outline what someone using the \TSL would be able to build based on the functions we've outlined. It must be noted that syntax may be different depending how it is actually implemented. Syntactic variations are acceptable in design/implementation as long as requirements are met.

\subsection{Initialization}
\begin{verbatim}
/*
 * Trains must be stopped, and we'll send signals to turn lights/horn off,
 * regardless of state.
 */

if isControlProgramRunning():
    error(“already running”);
readXML(filename)
runController(xmlDoc)
vector<train> trains = new vector<train>
t1 = new Train(244, 3, 4, 5, 6)    //initialized with ID and vector of sensors owned by it
trains.append(t1)
t2 = new Train(133, 19, 20, 24, 25, 26)
trains.append(t2)
t3 = new Train(212, 10, 11, 12)
trains.append(t3)
\end{verbatim}

\subsection{Starting While Running}
\begin{verbatim}
/*
 * Trains are assumed to be moving, and here we shall set up the initial
 * train objects based on querying the control program.
 */

readXML(filename)
if !isControlProgramRunning():
    error(“ctrl not running”)
trains = getTrains();
\end{verbatim}

\subsection{Slow Down Over Bridges}
\begin{verbatim}
/*
 * We've decided that we want to slow all trains down while going over
 * bridges for safety.
 */

# define the function that will be called when event occurs
def slowDown(train t, location l):
    s = t.getSpeed()
    if (s > 25):
        t.setSpeed(25)
        waitUntil(t.occupies(l))
        t.setSpeed(s)

# Get the sections on the bridge(s)
bridgeLoc = []
bridgeLoc.append(track.getLocation(5, 6))
bridgeLoc.append(track.getLocation(10, 11, 12))
bridgeLoc.append(track.getLocation(22, 23))

# let t be some list of all the trains we want to slow down for bridges
for t in trains:
    # Loop over all bridge sections and slow the train at all bridge sections
    for l in bridgeLoc:
        tEv = trainEvent(t.occupies(t, l), slowDown, 0);
        tEv.register()

#from now on, these train events will ensure that trains crossing bridges are slowed down!

\end{verbatim}
\subsection{Go to Mountains}
\begin{verbatim}
/*
 * We program the train to go to the mountains section that we define,
 * then once there we tell the train to sound it's horn.
 */

# let 35 be the section for the mountains
mountains = track.getSection(35)

# define the function we would like to register
def atMountains():
    train1.hornOn(5) # Duration = 5 secs
    train1.reverseDirection()

#here we tell the event handler to only register this function for 5 minutes.
t = trainEvent(mountains.entered(train1), atMountains, 60 * 60 * 5)

# Tell train1 to go to the mountains.
train1.gotoSection(mountains)



\end{verbatim}
\subsection{Manual Switch Control}
\begin{verbatim}
# Lets mess with some switches!

train1 = track.getTrain(1204)
switch1 = track.nextSwitch(train1)

if switch1.getSection().reserved():
    train1.stop()
end if

waituntil (NOT switch1.getSection().reserved())

# This makes the switch open or closed to allow the train to pass.
switch1.allowPass(train1)
train1.setSpeed(50)
\end{verbatim}

\end{document}
