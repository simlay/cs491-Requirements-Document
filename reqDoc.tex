\documentclass[a4paper,11pt,notitlepage]{article}
\usepackage{xspace}
\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{paralist}
\usepackage{hanging}
\usepackage{enumerate}
\usepackage{color}
\usepackage{hyperref}

\def\TSL{Train Scripting Language\xspace}
\def\CS{Control Progam\xspace}
\def\LC{Local Copy of Train State\xspace}
\title{{\bf Software Project Requirements Specification} \\ for \\ {\bf Train Scripting Python Library}}
\author{Prepared by Alex Wipf, Sebastian Imlay, Max Aussendorf, Paul Sheraton}
\parskip 7.2pt

\begin{document}
\maketitle
\pagebreak
\tableofcontents

%\addtocounter{page}{-1}
\section{Scope}
\subsection{Purpose}
Creation of a Python library to communicate with the control software for the model train in CF408. This library will allow users to create scripts which can control the trains without human interaction.
\subsection{Document Definitions}
\paragraph{\TSL} This refers to the Python with our library added on.
\paragraph{\CS} This refers to the AdaRail program which works between the virtual throttles (such as our Scripting Language) and the track itself. This is the program our library will directly communicate with.
\paragraph{\LC} Our library shall have a thread which listens to all messages, and update a local copy of the train states. For accessor functions, this local copy can be the one read.
\subsection{References}

\section{Vision}
Paul
\subsection{Background}
\subsection{Product Perspective}
\subsection{Risk Assessment}

\section{General Description}
\subsection{User Characteristics}
Users of this library will be programmers, and will be interested in the model trains. Since this is built on top of Python, anyone using it should be expected to know a bit of python before they start using our library. While the learning curve may be steeper than that of a manual throttle, this library will be much more powerful. We have specified objects and functionality in such a way that it should be intuative to manipulate the train system.
\subsection{Library Features}
Upon inclusion of the library, a user will be able to either start the \CS, or receive from it information about the current state of the train system. An XML document with the physical topology will have to be read in. The user will be able to call library functions, declare objects, and call methods on those objects. All of these features will be to allow the user to poll and manipulate the train system.

\section{Specific Requirements}
Alex
\subsection{Objects in Library}
\subsection{Functions in Library}
\subsubsection{Event Driven Functions}
Object: TrainEvent
\\t = TrainEvent(f1, f2, n)
\\f1, f2 are functions. f1 returns a boolean, f2 does the event's desired things.
\\n is the number of times the event can happen before it is automatically unregistered (0 == infinite)
\\functions on TrainEvents:
\\t.register()		--adds to observer's list of things to watch (no op if already exists)
\\t.unregister()	--removes from observer's list (no op if not exists)

\section{External Interface Requirements}
Sebastian\\
    In this section, we go over the general interface requirements for the train scripting language.
\subsection{Control Program}
    There shall be one or more threads which intaract between the control session and the current train script instance.
\subsection{Train Topology}

\section{Additions to Current Software}
Sebastian \\
    In this section, we go over what additions needed to be added to the
    current architecture.
\subsection{Design Constraints}
\subsection{Control Program}
    A messaging protocol between ``virtual'' remotes the control program shall be added.  This protocol is simply for initializing the train and knowing if the loco buffer server is running.
\subsection{XML Specification}
    The list of additions to the XML specification is:
\begin{enumerate}
    \item Length between each sensor on the track.
    \item Speedlimits on a given section.
\end{enumerate}

\section{Non-Functional Requirements}
\subsection{Performance Requirements}
\subsection{Security Requirements}
\subsection{Safety Requirements}

\section{Additional Functionality For Future Releases}
\subsection{Front End}
\subsection{Speed Limits}

\section{Sample Scripts}
In this section we outline what someone using the \TSL would be able to build based on the functions we've outlined.

\subsection{Initialization}
\begin{verbatim}
/*
 * Trains must be stopped, and we'll send signals to turn lights/horn off,
 * regardless of state.
 */

if isControlProgramRunning():
    error(“already running”);
runController
readXML(filename)
vector<train> trains = new vector<train>
t1 = new Train(244, 3, 4, 5, 6)    //initialized with ID and vector of sensors owned by it
trains.add(t1)
t2 = new Train(133, 19, 20, 24, 25, 26)
trains.add(t2)
t3 = new Train(212, 10, 11, 12)
trains.add(t3)
initControl(trains)     //sends msg to controller to start up, w/initial train locs
\end{verbatim}

\subsection{Starting While Running}
\begin{verbatim}
/*
 * Trains are assumed to be moving, and here we shall set up the initial
 * train objects based on querying the control program.
 */

readXML(filename)
if !isControlProgramRunning():
    error(“ctrl not running”)
	trains = getTrainState();
\end{verbatim}

\subsection{Slow Down Over Bridges}
\begin{verbatim}
/*
 * We've decided that we want to slow all trains down while going over
 * bridges for safety.
 */

# define the function that will be called when event occurs
def slowDown(train):
    s = train1.getSpeed()
	if (s > 25):
		train1.setSpeed(25)
		waitUntil(train1.location != section)
		    train1.setSpeed(s)

# Create the object for a certain train (#1204)
train1 = track.getTrain(1204)
train1.setSpeed(50)

# Get the sections on the bridge(s)
bridgeSections = track.getSections([(15,25), (23,44),(43,66)])

# Loop over all bridge sections and slow the train at all bridge sections
for section in bridgeSections:
    t = trainEvent(section.entered(train1), slowDown, 0);

\end{verbatim}
\subsection{Go to Mountains}
\begin{verbatim}
/*
 * We program the train to go to the mountains section that we define,
 * then once there we tell the train to sound it's horn.
 */

# let 35 be the section for the mountains
mountains = track.getSection(35)

# Tell train1 to go to the mountains.
train1.gotoSection(mountains)

# define the function we would like to register
def atMountains():
	train1.hornOn(5) # Duration = 5 secs
    train1.reverseDirection()

#here we tell the event handler to only register this function for 5 minutes.
t = trainEvent(mountains.entered(train1), atMountains, 60 * 60 * 5)



\end{verbatim}
\subsection{Manual Switch Control}
\begin{verbatim}
\end{verbatim}

\end{document}
